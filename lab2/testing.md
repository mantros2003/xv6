# Testing Undo Logging

## Testing Overview
Our testing methodology is that each test case
1. resets the filesystem; 
2. forcefully crash your OS at a pre-defined crash point;
3. verify that after reboot your logging implementation is able to recover the
filesystem to a consistent state.

The above methodology is realized by [check.sh](./check/check.sh) script. It
tests the undo log implementation in the following steps in a loop:

1. Write `00000` into `hello.txt`
2. Create a filesystem image containing `hello.txt` file
3. Replace the value of `LOG_FLAG` in `logflag.h` from the default value of 0
to 1, 2 ... 5 (each representing a crash at different stages)
4. Run `test_lab2.sh` which boots the OS with `make qemu` and captures the
output generated by the `log_test()` function
5. Change `LOG_FLAG` back to the default value of 0 (no failure)
6. Repeat Step 4
7. Compare the captured output with the expected output to decide which
testcases pass

As mentioned in step 3 in the previous section, `check.sh` changes `LOG_FLAG`
defined in `logflag.h`. This changes `PANIC_1`, `PANIC_2` etc flags.  `commit()`
function in `log.c` crashes at different points, based on these flags.

## Exercising the file system

In [main.c](./main.c), `main` calls `log_test` after boot. This function does 2
things:

1. Reads the contents of `hello.txt` into `buffer` and prints it as "[UNDOLOG]
READ: N XXXXX"
2. Each testcase from 1 to 5 flips the corresponding bit in `buffer` to 1.  For
example, testcase 2 will flip the 2nd bit to 1 changing the contents of `buffer`
to `01000`. This modified `buffer` is then written into `hello.txt` and the
written value is printed as "[UNDOLOG] WRITE: N XXXXX"

## Testcases

As mentioned earlier, each testcase simulates a crash at a different stage in
the write operation. The first boot crashes at the call to `filewrite` in
`log_test()` and the second boot proceeds without a crash.

### Testcases

`PANIC_1`, `PANIC_2`, `PANIC_3`, `PANIC_5` cause `commit()` to panic the OS
*before* committing, while `PANIC_4` panics the OS *after* committing the write
operation (i.e., after writing the new log header).

For all testcases, we see a log similar to follows for the first boot. This is
because READ executes normally and prints `00000` (the contents of `hello.txt`).
During the WRITE operation, the OS crashes and the corresponding panic output is
printed.

```
[UNDOLOG] READ: 5 00000
lapicid 0: panic: [UNDOLOG] Panic in commit type 1
```

For `PANIC_1`, `PANIC_2`, `PANIC_3`, `PANIC_5`, since the OS crashed *before*
committing the write. Therefore, in the second boot, the READ prints `00000` and
not `10000`, etc. as the last boot's write is not seen:

```
[UNDOLOG] READ: 5 00000
```

Whereas for `PANIC_4`, the OS crashed *after* committing the write. Therefore,
in the second boot, the READ prints `00010`, i.e., the last boot's write is
seen:

```
[UNDOLOG] READ: 5 00010
```

## Running the autograder
The autograding scripts can be found inside the folder named `check`.
Execute the following commands to run the autograder on your submission:

```
cd check
bash check.sh <path/to/lab2_<entryNumber>.tar.gz>
```

